#!/usr/bin/env node
'use strict';

var Metrics = require('../metrics')
  , colors = require('colors')
  , async = require('async')
  , path = require('path')
  , os = require('os');

//
// Setup the Command-Line Interface.
//
var cli = require('commander');

cli.usage(['[options] urls',
    ,'         urls like'
    ,'         http://ip:port/?params'
    ,'         http://ip:port/?params1  http://ip:port/?params2  ...'
    ,'         http://ip:port/?params@@192.168.102.53  --bind vip'].join("\n"))
   .option('-A, --amount <connections>', 'the amount of persistent connections to generate, default 1', parseInt, 1)
   .option('-C, --concurrent [connections]', '[deprecated]how many concurrent-connections per second, default to amount', parseInt, 0)
   .option('-M, --messages [messages]', 'number of messages to be send per connection, default 0', parseInt, 0)
   .option('-P, --protocol [protocol]', 'WebSocket protocol version, default 13', parseInt, 13)
   .option('-B, --buffer [size]', 'size of the messages that are send, default 1024', parseInt, 1024)
   .option('-W, --workers [cpus]', 'workers to be spawned, default cpus.length', parseInt, os.cpus().length)
   .option('-G, --generator [file]', 'custom message generators')
   .option('-M, --masked', 'send the messaged with a mask')
   .option('-b, --binary', 'send binary messages instead of utf-8')
   .option('-t, --connectTimeout [connectTimeout]', 'default 5(s)', parseInt, 5)
   .option('-l, --logError [logError]', 'default 0 means false, otherwise true', parseInt, 0)
   .option('--TP, --transport [transport]', '"polling"/"websocket" default websocket', 'websocket')
   .option('--PI, --pingInterval [seconds]', 'seconds for doing ping to keep-alive, default 50', parseInt, 50)
   .option('--SI, --statInterval [seconds]', 'show stat info interval, default 60', parseInt, 60)
   .option('--RT, --runtime [seconds]', 'timeout to close socket(seconds), default to unlimited, u must stop by ctrl+c', parseInt, -1)
   .version(require('../package.json').version)
   .parse(process.argv);


//
// Check if all required arguments are supplied, if we don't have a valid url we
// should bail out
//
if (!cli.args.length) return [
    '愚かな人類よ!'
  , 'You forgot to supply the urls.'
  , 'Type -h for help.'
].forEach(function stderr(line) {
  console.error(line);
});

//
// By Odin's beard, unleash thunder!
//
var cluster = require('cluster')
  , workers = cli.workers || 1
  , workers = Math.min(cli.amount * cli.args.length, workers)
  , forked_workers = workers
  , robin = []
  , task_ids = Object.create(null)
  , concurrents = Object.create(null)
  , created_connections = 0
  , closed_connections = 0
  , error_connections = 0
  , message_received = 0;

// master config
cluster.setupMaster({
    exec: path.resolve(__dirname, '../worker-socketio.js')
  , silent: false
  , args: [
      cli.generator
      ? path.resolve(process.cwd(), cli.generator)
      : path.resolve(__dirname, '../generator.js'),
      cli.protocol,
      !!cli.masked,
      !!cli.binary,
      cli.statInterval,
      cli.logError
    ]
});

// fork workder
while (workers--) cluster.fork();

// worker events setup & master exit event setup
Object.keys(cluster.workers).forEach(function each(id) {
  var worker = cluster.workers[id];
  /**
   * message from worker via IPC
   * @param  {Array|Object}  Object{wid:worker_id, concurrent:, datas:[{type:, id:connection_id, ...}, ...]}
   * @return null
   */
  worker.on('message', function message(msg) {
    
    // worker active connections
    concurrents[msg.wid] = msg.concurrent;

    for (var i = 0; i < msg.datas.length; i++) {
      var data = msg.datas[i];

      switch (data.type) {
        case 'open':
          ++created_connections;

          metrics.handshaken(data);
          worker.emit('open::'+ data.id);
          break;

        case 'close':
          ++closed_connections;

          delete task_ids[data.id];

          metrics.close(data);
          break;

        case 'error':
          ++error_connections;

          delete task_ids[data.id];

          metrics.error(data);
          break;

        case 'message':
          ++message_received;

          metrics.message(data);
      }

    }

    //
    // Check if we have processed all connections so we can quit cleanly.
    //
    if (!Object.keys(task_ids).length) process.exit();
  });

  // Add our worker to our round robin queue so we can balance all our requests
  // across the different workers that we spawned.
  robin.push(worker);
});

/**
 * live tick
 */
function tick() {
  var frames = live.frames
    , len = frames.length
    , i = 0;

  var active = Object.keys(concurrents).reduce(function (count, id) {
    return count + (concurrents[id] || 0);
  }, 0);

  // process.stdout.write('\r'+ frames[i++ % len] +' Progress :: '.white + [
  console.log('\r'+ frames[i++ % len] +' Progress :: '.white + [
    'Created '.white + created_connections.toString().green,
    'Active '.white + active.toString().green,
    'Closed '.white + closed_connections.toString().green,
    'Error '.white + error_connections.toString().green,
    'Message Received '.white + message_received.toString().green,
    '@'.white + new Date().toLocaleString().green
  ].join(', '));
}
//
// Output live, real-time stats.
//
function live() {
  var interval = cli.statInterval * 1000;
  live.interval = setInterval(tick, interval);
}

/**
 * Live frames.
 *
 * @type {Array}
 * @api private
 */
live.frames = [
    '  \u001b[96m◜ \u001b[90m'
  , '  \u001b[96m◠ \u001b[90m'
  , '  \u001b[96m◝ \u001b[90m'
  , '  \u001b[96m◞ \u001b[90m'
  , '  \u001b[96m◡ \u001b[90m'
  , '  \u001b[96m◟ \u001b[90m'
];

/**
 * Stop the live stats from running.
 *
 * @api private
 */
live.stop = function stop() {
  // process.stdout.write('\u001b[2K');
  clearInterval(live.interval);
  tick();
};

//
// Up our WebSocket socket connections.
//
console.log([
    ''
  , 'Thor:                                                  version: '+ cli._version
  , ''
  , 'God of Thunder, son of Odin and smasher of WebSockets!'
  , ''
  , 'Thou shall:'
  , '- Spawn '+ forked_workers +' workers.'
  , '- Create '+ (cli.concurrent || 'all the') + ' concurrent connections.'
  , '- Smash '+ (cli.amount || 'infinite') +' connections.'
  , ''
].join("\n"));

//
// Metrics collection.
//
var metrics = new Metrics(cli.amount * cli.args.length);

// Iterate over all the urls so we can target multiple locations at once, which
// is helpfull if you are testing multiple loadbalancer endpoints for example.
async.forEach(cli.args, function forEach(url, done) {
  var i = cli.amount
    , goOnTaskQueueWhileConcurrentLimited = (cli.concurrent && cli.concurrent < cli.amount);

  console.log('Connecting to %s @%s', url, new Date().toLocaleString());

  url = url.split('@@');
  var vip = url.length > 1 ? url[1] : null;
  url = url[0];
  //
  // Create a simple WebSocket connection generator.
  //
  var queue = async.queue(function working(id, fn) {
    var worker = robin.shift();

    // Register the id, so we can keep track of the connections that we still
    // need to process.
    task_ids[id] = 1;

    // Process the connections
    worker.send({ url: url, size: cli.buffer, messages: cli.messages, id: id
      , localaddr: vip
      , transport: cli.transport.split(',')
      , pingInterval: cli.pingInterval
      , nextTask: goOnTaskQueueWhileConcurrentLimited
      , runtime: cli.runtime
      , connectTimeout: cli.connectTimeout
    });

    // do it if cuncurrent is not 0 and smaller than the amount of all tcp connections
    if (goOnTaskQueueWhileConcurrentLimited) {
      worker.once('open::'+ id, fn);
    };

    // Add the worker back at the end of the round robin queue.
    robin.push(worker);
  }, cli.concurrent || Infinity);

  // When all the events are processed successfully we should call.. back ;P
  queue.drain = done;

  // Add all connections to the processing queue;
  while (i--) queue.push(url + (vip ? '::'+vip : '') +'::'+ i);
}, function established(err) {
  metrics.established();
});

//
// We are setup, everything is running
//
console.log('');
// live();
setTimeout(live, 1000);

process.once('SIGINT', function end() {
  robin.forEach(function nuke(worker) {
    try { worker.send({ shutdown: true }); }
    catch (e) {}
  });
});

process.once('exit', function summary() {
  live.stop();
  metrics.established().stop().summary();
});
