#!/usr/bin/env node
'use strict';

var Metrics = require('../metrics')
  , async = require('async')
  , path = require('path')
  , os = require('os');

//
// Setup the Command-Line Interface.
//
var cli = require('commander');

cli.usage('[options] ws://localhost[@@vip]')
   .option('-A, --amount <connections>', 'the amount of persistent connections to generate', parseInt, 10000)
   .option('-C, --concurrent <connections>[deprecated]', 'how many concurrent-connections per second', parseInt, 0)
   .option('-M, --messages <messages>', 'messages to be send per connection', parseInt, 0)
   .option('-P, --protocol <protocol>', 'WebSocket protocol version', parseInt, 13)
   .option('-B, --buffer <size>', 'size of the messages that are send', parseInt, 1024)
   .option('-W, --workers <cpus>', 'workers to be spawned', parseInt, os.cpus().length)
   .option('-G, --generator <file>', 'custom message generators')
   .option('-M, --masked', 'send the messaged with a mask')
   .option('-b, --binary', 'send binary messages instead of utf-8')
   .option('-T, --runtime <seconds>', 'timeout to close socket(seconds), default to unlimited and u must stop by ctrl+c', parseInt, -1)
   .version(require('../package.json').version)
   .parse(process.argv);

//
// Check if all required arguments are supplied, if we don't have a valid url we
// should bail out
//
if (!cli.args.length) return [
    'Thor:'
  , 'Odin is disapointed you... pithy human! You forgot to supply the urls.'
].forEach(function stderr(line) {
  console.error(line);
});

//
// By Odin's beard, unleash thunder!
//
var cluster = require('cluster')
  , worker_num = cli.workers || 1
  , worker_num = worker_num > cli.amount * cli.args.length ? cli.amount * cli.args.length : worker_num
  , forked_worker_num = worker_num
  , connect_ids = Object.create(null)
  , connections = 0
  , connecteds = {}
  , received = 0
  , robin = [];

cluster.setupMaster({
    exec: path.resolve(__dirname, '../worker-socketio.js')
  , silent: false
  , args: [
      cli.generator
      ? path.resolve(process.cwd(), cli.generator)
      : path.resolve(__dirname, '../generator.js'),
      cli.protocol,
      !!cli.masked,
      !!cli.binary
    ]
});

while (worker_num--) cluster.fork();

Object.keys(cluster.workers).forEach(function each(id) {
  var worker = cluster.workers[id];

  worker.on('message', function message(data) {
  
  var datas = [];
  if (data.collection) {
    datas = data.datas;
  }else{
    datas = [data];
  }
  for (var i = 0; i < datas.length; i++) {
    var data = datas[i];

    switch (data.type) {
      case 'connected':
        connecteds[data.worker_id] = data.connected;
        var all_connected = 0,
            all_workers = 0;
        Object.keys(connecteds).forEach(function each(id) {
          all_workers++;
          all_connected += connecteds[id];
          console.log('[Master] %s connected, msg received %s in workers %s', connecteds[id], data.received_msg, id);
        });
        // Output the connection progress
        console.log('[Master] %s connected, in %s workers' + "\n", all_connected, all_workers);
        break;

      case 'opened':
        worker.emit('opened::'+ data.id);

        // Output the connection progress
        if (++connections % 100 === 0) {
          console.log('  Opened %s connections', connections);
        }

        break;

      case 'open':
        metrics.handshaken(data);
        // worker.emit('open::'+ data.id);

        // Output the connection progress
        /*if (++connections % 1000 === 0) {
          console.log('  Opened %s connections', connections);
        }*/

        break;

      case 'close':
        delete connect_ids[data.id];

        metrics.close(data);
        // worker.emit('close::'+ data.id);
        break;

      case 'error':
        delete connect_ids[data.id];

        metrics.error(data);
        // worker.emit('error::'+ data.id);
        break;

      case 'message':
        received++;
        metrics.message(data);
        // worker.emit('message::'+ data.id);

    }

  }

    //
    // Check if we have processed all connections so we can quit cleanly.
    //
    if (!Object.keys(connect_ids).length) process.exit();
  });

  // Add our worker to our round robin queue so we can balance all our requests
  // across the different workers that we spawned.
  robin.push(worker);
});

//
// Up our WebSocket socket connections.
//
[
    ''
  , 'Thor:                                                  version: '+ cli._version
  , ''
  , 'God of Thunder, son of Odin and smasher of WebSockets!'
  , ''
  , 'Thou shall:'
  , '- Spawn '+ forked_worker_num +' workers.'
  , '- Create '+ (cli.concurrent || 'all the') + ' concurrent/parallel connections.'
  , '- Smash '+ (cli.amount || 'infinite') +' connections with the mighty MjÃ¶lnir.'
  , ''
  , 'The answers you seek shall be yours, once I claim what is mine.'
  , ''
].forEach(function stdout(line) {
  console.log(line);
});

//
// Metrics collection.
//
var metrics = new Metrics(cli.amount * cli.args.length);

// Iterate over all the urls so we can target multiple locations at once, which
// is helpfull if you are testing multiple loadbalancer endpoints for example.
async.forEach(cli.args, function forEach(url, done) {
  var i = cli.amount
    , completed = 0;

  console.log('Connecting to %s', url);

  url = url.split('@@');
  var localaddr = url.length > 1 ? url[1] : null;
  url = url[0];
  //
  // Create a simple WebSocket connection generator.
  //
  var queue = async.queue(function working(connect_id, fn) {
    var worker = robin.shift();

    // Register the id, so we can keep track of the connections that we still
    // need to process.
    connect_ids[connect_id] = 1;

    // Process the connections
    worker.send({ url: url, size: cli.buffer, messages: cli.messages, id: connect_id, runtime: cli.runtime, localaddr: localaddr, send_opened: (cli.concurrent && cli.concurrent < cli.amount) });

    // do it if cuncurrent is not 0 and smaller than the amount of all tcp connections
    // we have to set this event to roll process to next connect
    if (cli.concurrent && cli.concurrent < cli.amount) {
      worker.once('opened::'+ connect_id, fn);
    };

    // Add the worker back at the end of the round robin queue.
    robin.push(worker);
  }, cli.concurrent || Infinity);

  // When all the events are processed successfully we should call.. back ;P
  queue.drain = done;

  // Add all connections to the processing queue; //.push(connect_id)
  while (i--) queue.push(url + (localaddr ? '::'+localaddr : '') +'::'+ i);
}, function established(err) {
  metrics.established();
});

console.log('');

// ctrl + c
process.on('SIGINT', function end() {
  robin.forEach(function nuke(worker) {
    try { worker.send({ shutdown: true }); }
    catch (e) {}
  })
});

process.on('exit', function summary() {
  console.log('-----------------');

  metrics.established().stop().summary();
});
